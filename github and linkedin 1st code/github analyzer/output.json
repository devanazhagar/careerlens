{
  "repoName": "thiyaroshni17/escloop",
  "detectedStack": "node_js",
  "timestamp": "2026-01-30T18:57:20.091Z",
  "totalFiles": 6,
  "fileTree": [
    "client/README.md",
    "client/eslint.config.js",
    "client/index.html",
    "client/package-lock.json",
    "client/package.json",
    "client/src/App.jsx",
    "client/src/components/EquipmentDetailsModal.jsx",
    "client/src/components/GlobalAttendanceListener.jsx",
    "client/src/components/LeadDetailsModal.jsx",
    "client/src/components/MemberDetailsModal.jsx",
    "client/src/components/PlanDetailsModal.jsx",
    "client/src/components/Sidebar.jsx",
    "client/src/components/StaffDetailsModal.jsx",
    "client/src/components/ToggleButton.jsx",
    "client/src/context/context.jsx",
    "client/src/main.jsx",
    "client/src/pages/AccountSettings.jsx",
    "client/src/pages/Addequip.jsx",
    "client/src/pages/Addexpense.jsx",
    "client/src/pages/Addlead.jsx",
    "client/src/pages/Addmember.jsx",
    "client/src/pages/Addstaff.jsx",
    "client/src/pages/Attendance.jsx",
    "client/src/pages/AttendanceDayView.jsx",
    "client/src/pages/Attendancecalendar.jsx",
    "client/src/pages/Billlisting.jsx",
    "client/src/pages/BusinessInsights.jsx",
    "client/src/pages/Dashboard.jsx",
    "client/src/pages/Equiplist.jsx",
    "client/src/pages/Expenselist.jsx",
    "client/src/pages/Expenselist_new.jsx",
    "client/src/pages/Fitnesslisting.jsx",
    "client/src/pages/Forgotpassword.jsx",
    "client/src/pages/Landing.jsx",
    "client/src/pages/Leadslisting.jsx",
    "client/src/pages/Membership.jsx",
    "client/src/pages/Memberslisting.jsx",
    "client/src/pages/Newsub.jsx",
    "client/src/pages/NotificationsReminders.jsx",
    "client/src/pages/Payment.jsx",
    "client/src/pages/PersonalizedPlan.jsx",
    "client/src/pages/PlanView.jsx",
    "client/src/pages/Planslisting.jsx",
    "client/src/pages/Revenue.jsx",
    "client/src/pages/Salary.jsx",
    "client/src/pages/StaffView.jsx",
    "client/src/pages/Stafflisting.jsx",
    "client/src/pages/Subscriptions.jsx",
    "client/src/pages/WhatsAppConnection.jsx",
    "client/src/pages/addfitness.jsx",
    "client/src/pages/billing.jsx",
    "client/src/styles/addequip.css",
    "client/src/styles/addlead.css",
    "client/src/styles/business-insights.css",
    "client/src/styles/dashboard.css",
    "client/src/styles/fitnesslisting.css",
    "client/src/styles/index.css",
    "client/src/styles/leadslisting.css",
    "client/src/styles/notifications-reminders.css",
    "client/src/styles/sidebar.css",
    "client/src/styles/toggle-button.css",
    "client/vite.config.js",
    "diag_dups.js",
    "server/check_non_active.js",
    "server/check_roshni.js",
    "server/check_staff_conflict.js",
    "server/controller/attendance.js",
    "server/controller/bill.js",
    "server/controller/equipment.js",
    "server/controller/expense.js",
    "server/controller/fitness.js",
    "server/controller/gymSettings.js",
    "server/controller/lead.js",
    "server/controller/member.js",
    "server/controller/membership.js",
    "server/controller/revenue.js",
    "server/controller/staff.js",
    "server/controller/subscription.js",
    "server/controller/user.js",
    "server/database/db.js",
    "server/database/nodemailer.js",
    "server/diag_dups.js",
    "server/find_inactive.js",
    "server/fitness-api-server.js",
    "server/fix_roshni.js",
    "server/fix_staff_indexes.js",
    "server/food.csv",
    "server/middleware/userauth.js",
    "server/models/GymSettings.js",
    "server/models/attendance.js",
    "server/models/bill.js",
    "server/models/equipment.js",
    "server/models/expense.js",
    "server/models/fitness.js",
    "server/models/lead.js",
    "server/models/member.js",
    "server/models/membership.js",
    "server/models/staff.js",
    "server/models/staffSalary.js",
    "server/models/subscription.js",
    "server/models/usermodel.js",
    "server/package-lock.json",
    "server/package.json",
    "server/results.json",
    "server/routes/equipmentroutes.js",
    "server/routes/expenseroutes.js",
    "server/routes/fitnessroutes.js",
    "server/routes/plansroutes.js",
    "server/routes/userroutes.js",
    "server/server.js",
    "server/services/churnService.js",
    "server/services/fitnessService.js",
    "server/services/webhookService.js",
    "server/utils/expenseUtils.js",
    "server/utils/invoiceUtils.js",
    "server/utils/planUtils.js",
    "server/utils/statusUtils.js",
    "server/workout.csv"
  ],
  "files": [
    {
      "path": "server/server.js",
      "content": [
        "process.env.TZ = 'Asia/Kolkata';",
        "const express = require('express');",
        "const app = express();",
        "require('dotenv').config();",
        "const cors = require('cors');",
        "const cookieparser = require('cookie-parser');",
        "const Router = require('./routes/userroutes.js');",
        "const plansRouter = require('./routes/plansroutes.js');",
        "const expenseRouter = require('./routes/expenseroutes.js');",
        "const fitnessRouter = require('./routes/fitnessroutes.js');",
        "const equipmentRouter = require('./routes/equipmentroutes.js');",
        "const { connectDB } = require('./database/db.js');",
        "const path = require('path');",
        "const fs = require('fs');",
        "const { runChurnAnalysis } = require('./services/churnService.js');",
        "const { loadFitnessData } = require('./services/fitnessService.js');",
        "const cron = require('node-cron');",
        "const { sendExpiryReminderWebhook, sendLeadFollowUpWebhook } = require('./services/webhookService.js');",
        "",
        "connectDB().then(() => {",
        "  // Run Churn Analysis once DB is connected",
        "  runChurnAnalysis();",
        "  // Load Fitness CSV data",
        "  loadFitnessData();",
        "});",
        "const PORT = process.env.PORT || 5000;",
        "app.use(express.json())",
        "app.use(cors({ origin: [process.env.FRONTEND_URL], credentials: true }))",
        "app.use(cookieparser())",
        "",
        "// Serve static files from uploads directory (use absolute path)",
        "app.use('/uploads', express.static(path.join(__dirname, 'uploads')));",
        "",
        "// Serve static files from public directory for invoices and other public assets",
        "app.use('/public', express.static(path.join(__dirname, 'public')));",
        "",
        "app.use('/gym', Router)",
        "",
        "// Direct routes for plans (without /gym prefix)",
        "app.use('/plans', plansRouter);",
        "",
        "// Direct routes for expenses (with /gym prefix to match frontend configuration)",
        "app.use('/gym/expenses', expenseRouter);",
        "app.use('/gym/fitness', fitnessRouter);",
        "app.use('/gym/equipment', equipmentRouter);",
        "",
        "// Endpoint to list files in uploads/plans directory",
        "app.get('/api/plans/files', (req, res) => {",
        "  const plansDir = path.join(__dirname, 'uploads', 'plans');",
        "  fs.readdir(plansDir, (err, files) => {",
        "    if (err) {",
        "      console.error('Error reading plans directory:', err);",
        "      return res.status(500).json({ success: false, message: 'Error reading directory' });",
        "    }",
        "    res.json({ success: true, files });",
        "  });",
        "});",
        "",
        "// ========================================",
        "// NOTIFICATIONS & REMINDERS ENDPOINTS",
        "// ========================================",
        "",
        "// Endpoint to get members with pending payments",
        "app.get('/api/notifications/pending-payments', async (req, res) => {",
        "  try {",
        "    const MemberModel = require('./models/member.js');",
        "",
        "    // Query members with balance amount greater than 0 and status 'Pending'",
        "    const membersWithPending = await MemberModel.find({",
        "      balanceAmount: { $gt: 0 },",
        "      status: 'Pending'",
        "    })",
        "      .select('memberId fullName balanceAmount phone email packageName membershipType amount profilePhoto discountType discountValue netPayable')",
        "      .sort({ balanceAmount: -1 }); // Highest pending amount first",
        "",
        "    res.json({ success: true, members: membersWithPending });",
        "  } catch (error) {",
        "    console.error('Error fetching pending payments:', error);",
        "    res.status(500).json({ success: false, message: 'Failed to fetch pending payments' });",
        "  }",
        "});",
        "",
        "// Endpoint to get members expiring within next 7 days",
        "app.get('/api/notifications/expiring-soon', async (req, res) => {",
        "  try {",
        "    const MemberModel = require('./models/member.js');",
        "    const SubscriptionModel = require('./models/subscription.js');",
        "",
        "    const now = new Date();",
        "    now.setHours(0, 0, 0, 0); // Start of today",
        "",
        "    const sevenDaysLater = new Date();",
        "    sevenDaysLater.setDate(now.getDate() + 7);",
        "    sevenDaysLater.setHours(23, 59, 59, 999); // End of day 7 days from now",
        "",
        "    // 1. Get members whose current known endDate is within next 7 days",
        "    const expiringMembers = await MemberModel.find({",
        "      endDate: { $gte: now, $lte: sevenDaysLater },",
        "      status: { $in: ['Active', 'Pending'] }",
        "    })",
        "      .select('memberId fullName packageName endDate phone email membershipType amount profilePhoto')",
        "      .sort({ endDate: 1 });",
        "",
        "    // 2. Filter out members who have a newer active plan and calculate days left",
        "    const filteredMembers = await Promise.all(expiringMembers.map(async (member) => {",
        "      // Check if there's any other subscription for this member that ends AFTER this one",
        "      const newerPlan = await SubscriptionModel.findOne({",
        "        memberId: member._id,",
        "        status: { $in: ['Active', 'Pending'] },",
        "        endDate: { $gt: member.endDate }",
        "      });",
        "",
        "      if (newerPlan) return null; // Hide if they have a newer plan",
        "",
        "      // Calculate days left",
        "      const diffTime = member.endDate.getTime() - now.getTime();",
        "      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));",
        "",
        "      const memberObj = member.toObject();",
        "      memberObj.expiryStatus = diffDays === 0 ? \"Expires Today\" : `Expires in ${diffDays} day${diffDays > 1 ? 's' : ''}`;",
        "      memberObj.daysLeft = diffDays;",
        "",
        "      return memberObj;",
        "    }));",
        "",
        "    res.json({ success: true, members: filteredMembers.filter(m => m !== null) });",
        "  } catch (error) {",
        "    console.error('Error fetching expiring members:', error);",
        "    res.status(500).json({ success: false, message: 'Failed to fetch expiring members' });",
        "  }",
        "});",
        "",
        "// Endpoint to get members with finished subscriptions (expired)",
        "app.get('/api/notifications/subscription-finished', async (req, res) => {",
        "  try {",
        "    const MemberModel = require('./models/member.js');",
        "    const SubscriptionModel = require('./models/subscription.js');",
        "",
        "    const now = new Date();",
        "    now.setHours(0, 0, 0, 0); // Start of today",
        "",
        "    // 1. Get members whose current known endDate is in the past",
        "    const finishedMembers = await MemberModel.find({",
        "      endDate: { $lt: now }",
        "    })",
        "      .select('memberId fullName packageName endDate phone email membershipType amount profilePhoto')",
        "      .sort({ endDate: -1 })",
        "      .limit(100);",
        "",
        "    // 2. Filter out members who have an active future plan",
        "    const filteredMembers = await Promise.all(finishedMembers.map(async (member) => {",
        "      const activePlan = await SubscriptionModel.findOne({",
        "        memberId: member._id,",
        "        status: { $in: ['Active', 'Pending'] },",
        "        endDate: { $gte: now }",
        "      });",
        "",
        "      if (activePlan) return null; // Hide if they have an active plan now",
        "",
        "      const memberObj = member.toObject();",
        "      memberObj.expiryStatus = \"Expired\";",
        "      memberObj.daysLeft = -1;",
        "",
        "      return memberObj;",
        "    }));",
        "",
        "    res.json({ success: true, members: filteredMembers.filter(m => m !== null) });",
        "  } catch (error) {",
        "    console.error('Error fetching subscription finished members:', error);",
        "    res.status(500).json({ success: false, message: 'Failed to fetch subscription finished members' });",
        "  }",
        "});",
        "",
        "// Endpoint to get members with birthdays today",
        "app.get('/api/notifications/birthdays-today', async (req, res) => {",
        "  try {",
        "    const MemberModel = require('./models/member.js');",
        "",
        "    const today = new Date();",
        "    const currentMonth = today.getMonth() + 1; // 1-12",
        "    const currentDay = today.getDate(); // 1-31",
        "",
        "    // Use aggregation to extract month and day from dob field",
        "    const birthdayMembers = await MemberModel.aggregate([",
        "      {",
        "        $addFields: {",
        "          dobMonth: { $month: \"$dob\" },",
        "          dobDay: { $dayOfMonth: \"$dob\" }",
        "        }",
        "      },",
        "      {",
        "        $match: {",
        "          dobMonth: currentMonth,",
        "          dobDay: currentDay,",
        "          dob: { $ne: null }",
        "        }",
        "      },",
        "      {",
        "        $project: {",
        "          memberId: 1,",
        "          fullName: 1,",
        "          dob: 1,",
        "          phone: 1,",
        "          email: 1",
        "        }",
        "      },",
        "      {",
        "        $sort: { fullName: 1 }",
        "      }",
        "    ]);",
        "",
        "    res.json({ success: true, members: birthdayMembers });",
        "  } catch (error) {",
        "    console.error('Error fetching birthday members:', error);",
        "    res.status(500).json({ success: false, message: 'Failed to fetch birthday members' });",
        "  }",
        "});",
        "",
        "// Endpoint to get urgent lead follow-ups",
        "app.get('/api/notifications/urgent-followups', async (req, res) => {",
        "  try {",
        "    const LeadModel = require('./models/lead.js');",
        "",
        "    const today = new Date();",
        "    today.setHours(23, 59, 59, 999); // End of today",
        "",
        "    const nextWeek = new Date();",
        "    nextWeek.setDate(today.getDate() + 7);",
        "    nextWeek.setHours(23, 59, 59, 999);",
        "",
        "    const urgentLeads = await LeadModel.find({",
        "      nextFollowUpDate: { $lte: nextWeek },",
        "      status: { $nin: ['converted', 'lost'] }",
        "    })",
        "      .select('name phone email source lastContactedDate nextFollowUpDate status interestLevel interestedService')",
        "      .sort({ nextFollowUpDate: 1 }); // Oldest first",
        "",
        "    res.json({ success: true, leads: urgentLeads });",
        "  } catch (error) {",
        "    console.error('Error fetching urgent followups:', error);",
        "    res.status(500).json({ success: false, message: 'Failed to fetch urgent followups' });",
        "  }",
        "});",
        "",
        "// Endpoint to mark lead as contacted",
        "app.post('/api/notifications/lead-contacted/:id', async (req, res) => {",
        "  try {",
        "    const LeadModel = require('./models/lead.js');",
        "    const { id } = req.params;",
        "",
        "    const lead = await LeadModel.findById(id);",
        "    if (!lead) {",
        "      return res.status(404).json({ success: false, message: 'Lead not found' });",
        "    }",
        "",
        "    const today = new Date();",
        "    lead.lastContactedDate = today;",
        "",
        "    // Update status to 'contacted' if it was 'new'",
        "    if (lead.status === 'new') {",
        "      lead.status = 'contacted';",
        "    }",
        "",
        "    await lead.save();",
        "",
        "    res.json({ success: true, message: 'Lead status updated', lead });",
        "  } catch (error) {",
        "    console.error('Error marking lead as contacted:', error);",
        "    res.status(500).json({ success: false, message: 'Failed to mark lead as contacted' });",
        "  }",
        "});",
        "",
        "// Endpoint to get equipment maintenance schedule",
        "app.get('/api/notifications/equipment-maintenance', async (req, res) => {",
        "  try {",
        "    const EquipmentModel = require('./models/equipment.js');",
        "",
        "    const today = new Date();",
        "    const nextWeek = new Date();",
        "    nextWeek.setDate(today.getDate() + 7);",
        "",
        "    const equipmentList = await EquipmentModel.find({",
        "      maintenanceSchedule: { $lte: nextWeek }",
        "    })",
        "      .select('name category brand model serialNumbers maintenanceSchedule lastServiced statuses maintenanceDays')",
        "      .sort({ maintenanceSchedule: 1 }); // Soonest first",
        "",
        "    res.json({ success: true, equipment: equipmentList });",
        "  } catch (error) {",
        "    console.error('Error fetching equipment maintenance:', error);",
        "    res.status(500).json({ success: false, message: 'Failed to fetch equipment maintenance' });",
        "  }",
        "});",
        "",
        "// Endpoint to mark equipment maintenance as done",
        "app.post('/api/notifications/maintenance-done/:id', async (req, res) => {",
        "  try {",
        "    const EquipmentModel = require('./models/equipment.js');",
        "    const { id } = req.params;",
        "",
        "    const equipment = await EquipmentModel.findById(id);",
        "    if (!equipment) {",
        "      return res.status(404).json({ success: false, message: 'Equipment not found' });",
        "    }",
        "",
        "    const today = new Date();",
        "    const maintenanceDays = equipment.maintenanceDays || 30; // Default to 30 if not set",
        "    const nextMaintenance = new Date();",
        "    nextMaintenance.setDate(today.getDate() + maintenanceDays);",
        "",
        "    equipment.lastServiced = today;",
        "    equipment.maintenanceSchedule = nextMaintenance;",
        "",
        "    // Set all statuses to available after maintenance",
        "    if (equipment.statuses && equipment.statuses.length > 0) {",
        "      equipment.statuses = equipment.statuses.map(() => 'available');",
        "    }",
        "",
        "    await equipment.save();",
        "",
        "    res.json({ success: true, message: 'Maintenance recorded and schedule updated' });",
        "  } catch (error) {",
        "    console.error('Error marking maintenance as done:', error);",
        "    res.status(500).json({ success: false, message: 'Failed to mark maintenance as done' });",
        "  }",
        "});",
        "app.get('/api/notifications/attendance-alerts', async (req, res) => {",
        "  try {",
        "    const MemberModel = require('./models/member.js');",
        "    const AttendanceModel = require('./models/attendance.js');",
        "",
        "    const today = new Date();",
        "    today.setHours(0, 0, 0, 0);",
        "",
        "    const fiveDaysAgo = new Date();",
        "    fiveDaysAgo.setDate(today.getDate() - 5);",
        "",
        "    // 1. Get all active & pending members",
        "    const relevantMembers = await MemberModel.find({",
        "      status: { $in: ['Active', 'Pending'] }",
        "    }).select('memberId fullName phone profilePhoto membershipType packageName endDate lastAttendanceCalledDate');",
        "",
        "    // 2. Get the last present attendance record for each member",
        "    const absentMembers = await Promise.all(relevantMembers.map(async (m) => {",
        "      const lastAttendance = await AttendanceModel.findOne({",
        "        entityId: m.memberId,",
        "        type: 'member',",
        "        status: 'present'",
        "      }).sort({ date: -1 });",
        "",
        "      let daysAbsent = 0;",
        "      if (lastAttendance) {",
        "        const lastDate = new Date(lastAttendance.date);",
        "        const timeDiff = today.getTime() - lastDate.getTime();",
        "        daysAbsent = Math.floor(timeDiff / (1000 * 60 * 60 * 24));",
        "      } else {",
        "        // If no attendance recorded, calculate from startDate",
        "        const startDate = m.startDate ? new Date(m.startDate) : new Date(m.createdAt);",
        "        const timeDiff = today.getTime() - startDate.getTime();",
        "        daysAbsent = Math.floor(timeDiff / (1000 * 60 * 60 * 24));",
        "      }",
        "",
        "      // If they haven't been called in last 5 days AND absent for 5+ days",
        "      if (daysAbsent >= 5) {",
        "        if (m.lastAttendanceCalledDate) {",
        "          const lastCall = new Date(m.lastAttendanceCalledDate);",
        "          const diffTime = Math.abs(today - lastCall);",
        "          const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));",
        "          if (diffDays <= 5) return null;",
        "        }",
        "",
        "        return {",
        "          _id: m._id,",
        "          memberId: m.memberId,",
        "          fullName: m.fullName,",
        "          phone: m.phone,",
        "          profilePhoto: m.profilePhoto,",
        "          membershipType: m.membershipType,",
        "          packageName: m.packageName,",
        "          endDate: m.endDate,",
        "          type: 'Absence Streak',",
        "          daysAbsent: daysAbsent",
        "        };",
        "      }",
        "      return null;",
        "    }));",
        "",
        "    res.json({ success: true, members: absentMembers.filter(m => m !== null) });",
        "  } catch (error) {",
        "    console.error('Error fetching attendance alerts:', error);",
        "    res.status(500).json({ success: false, message: 'Failed to fetch attendance alerts' });",
        "  }",
        "});",
        "",
        "// Endpoint to mark member as called for attendance",
        "app.post('/api/notifications/attendance-called/:id', async (req, res) => {",
        "  try {",
        "    const MemberModel = require('./models/member.js');",
        "    const { id } = req.params;",
        "",
        "    const member = await MemberModel.findById(id);",
        "    if (!member) {",
        "      return res.status(404).json({ success: false, message: 'Member not found' });",
        "    }",
        "",
        "    member.lastAttendanceCalledDate = new Date();",
        "    await member.save();",
        "",
        "    res.json({ success: true, message: 'Attendance call recorded' });",
        "  } catch (error) {",
        "    console.error('Error marking attendance as called:', error);",
        "    res.status(500).json({ success: false, message: 'Failed to record attendance call' });",
        "  }",
        "});",
        "",
        "// Endpoint to get salary alerts with detailed metrics for the previous month",
        "app.get('/api/notifications/salary-alerts', async (req, res) => {",
        "  try {",
        "    const StaffModel = require('./models/staff.js');",
        "    const StaffSalaryModel = require('./models/staffSalary.js');",
        "    const AttendanceModel = require('./models/attendance.js');",
        "",
        "    const today = new Date();",
        "    const prevMonthDate = new Date(today.getFullYear(), today.getMonth() - 1, 1);",
        "    const prevMonthStr = prevMonthDate.getFullYear() + '-' + (prevMonthDate.getMonth() + 1).toString().padStart(2, '0');",
        "    const [year, month] = prevMonthStr.split('-');",
        "",
        "    // 1. Get all active staff",
        "    const activeStaff = await StaffModel.find({ status: 'Active' })",
        "      .select('staffId fullName salary role department phone profilePhoto workDays');",
        "",
        "    // 2. Get salary records for previous month",
        "    const salaryRecords = await StaffSalaryModel.find({ month: prevMonthStr });",
        "    const salaryStatusMap = {};",
        "    salaryRecords.forEach(r => { salaryStatusMap[r.staffId] = r; });",
        "",
        "    // 3. Get attendance for calculation",
        "    const startOfMonth = new Date(today.getFullYear(), today.getMonth() - 1, 1);",
        "    const endOfMonth = new Date(today.getFullYear(), today.getMonth(), 0, 23, 59, 59, 999);",
        "",
        "    const attendanceRecords = await AttendanceModel.find({",
        "      date: { $gte: startOfMonth, $lte: endOfMonth },",
        "      status: 'present'",
        "    });",
        "",
        "    const attendanceMap = {};",
        "    attendanceRecords.forEach(a => {",
        "      attendanceMap[a.entityId] = (attendanceMap[a.entityId] || 0) + 1;",
        "    });",
        "",
        "    // 4. Calculate metrics for unpaid staff",
        "    const unpaidStaff = activeStaff.filter(s => !salaryStatusMap[s.staffId] || salaryStatusMap[s.staffId].status !== 'Paid')",
        "      .map(s => {",
        "        const record = salaryStatusMap[s.staffId];",
        "",
        "        // Simple calculation logic (similar to attendance controller)",
        "        const daysInMonth = new Date(year, month, 0).getDate();",
        "        // Assume all days are potential work days for now or use staff workDays",
        "        // For accurate count, we'd need gym activity check, but for notifications, we'll simplify",
        "        const totalWorkingDays = record ? record.totalWorkingDays : 26; // Fallback to 26",
        "        const presentDays = record ? record.presentDays : (attendanceMap[s.staffId] || 0);",
        "        const absentDays = record ? record.absentDays : Math.max(0, totalWorkingDays - presentDays);",
        "",
        "        // Calculate amount proportional to attendance",
        "        const finalAmount = record ? record.finalAmount : Math.round((s.salary / totalWorkingDays) * presentDays);",
        "",
        "        return {",
        "          _id: s._id,",
        "          staffId: s.staffId,",
        "          fullName: s.fullName,",
        "          phone: s.phone,",
        "          profilePhoto: s.profilePhoto,",
        "          month: prevMonthStr,",
        "          year: year,",
        "          monthName: prevMonthDate.toLocaleString('default', { month: 'long' }),",
        "          salary: s.salary,",
        "          finalAmount,",
        "          totalWorkingDays,",
        "          presentDays,",
        "          absentDays,",
        "          role: s.role,",
        "          department: s.department,",
        "          status: record ? record.status : 'Unpaid'",
        "        };",
        "      });",
        "",
        "    res.json({ success: true, month: prevMonthStr, staff: unpaidStaff });",
        "  } catch (error) {",
        "    console.error('Error fetching salary alerts:', error);",
        "    res.status(500).json({ success: false, message: 'Failed to fetch salary alerts' });",
        "  }",
        "});",
        "",
        "// Endpoint to mark staff salary as paid and record in expenditure",
        "app.post('/api/notifications/salary-paid', async (req, res) => {",
        "  try {",
        "    const StaffSalaryModel = require('./models/staffSalary.js');",
        "    const StaffModel = require('./models/staff.js');",
        "    const { Expense } = require('./models/expense.js');",
        "    const { generateExpenseId } = require('./utils/expenseUtils.js');",
        "",
        "    const { staffId, month, finalAmount, presentDays, absentDays, totalWorkingDays, baseSalary } = req.body;",
        "",
        "    if (!staffId || !month) {",
        "      return res.status(400).json({ success: false, message: \"Staff ID and Month are required\" });",
        "    }",
        "",
        "    // 1. Mark as Paid in StaffSalary",
        "    const salary = await StaffSalaryModel.findOneAndUpdate(",
        "      { staffId, month },",
        "      {",
        "        staffId,",
        "        month,",
        "        baseSalary,",
        "        presentDays,",
        "        absentDays,",
        "        totalWorkingDays,",
        "        finalAmount,",
        "        status: 'Paid',",
        "        paymentDate: new Date(),",
        "        paymentMode: 'Cash'",
        "      },",
        "      { upsert: true, new: true }",
        "    );",
        "",
        "    // 2. Add to Expenditure (Expense Model)",
        "    const staff = await StaffModel.findOne({ staffId });",
        "    const expenseId = await generateExpenseId();",
        "",
        "    const monthName = new Date(month + '-01').toLocaleString('default', { month: 'long', year: 'numeric' });",
        "",
        "    await Expense.create({",
        "      expenseId,",
        "      title: `Salary Payment - ${staff ? staff.fullName : staffId} (${monthName})`,",
        "      category: 'salaries',",
        "      amount: finalAmount,",
        "      totalWithGst: finalAmount,",
        "      date: new Date(),",
        "      paymentMode: 'cash',",
        "      notes: `Staff Salary for ${monthName}. Present: ${presentDays}, Absent: ${absentDays}`",
        "    });",
        "",
        "    res.json({ success: true, message: 'Salary marked as paid and recorded in expenditure', data: salary });",
        "  } catch (error) {",
        "    console.error(\"Error marking salary paid:\", error);",
        "    res.status(500).json({ success: false, message: error.message });",
        "  }",
        "});",
        "",
        "// Endpoint to get high churn risk members",
        "app.get('/api/insights/high-risk', async (req, res) => {",
        "  try {",
        "    const MemberModel = require('./models/member.js');",
        "    // Fetch members with High Risk status or score > 0.75",
        "    // Sort by highest risk score first",
        "    const highRiskMembers = await MemberModel.find({",
        "      $or: [",
        "        { churnRisk: \"High Risk\" },",
        "        { churnScore: { $gt: 0.75 } }",
        "      ]",
        "    })",
        "      .select('memberId fullName packageName churnScore churnRisk phone email area city profilePhoto status')",
        "      .sort({ churnScore: -1 })",
        "      .limit(20);",
        "",
        "    res.json({ success: true, members: highRiskMembers });",
        "  } catch (error) {",
        "    console.error('Error fetching high risk members:', error);",
        "    res.status(500).json({ success: false, message: 'Failed to fetch high risk members' });",
        "  }",
        "});",
        "",
        "// Endpoint to get leads insights (count this month + recent)",
        "app.get('/api/insights/leads', async (req, res) => {",
        "  try {",
        "    const LeadModel = require('./models/lead.js');",
        "",
        "    // 1. Calculate start of current month",
        "    const now = new Date();",
        "    const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);",
        "",
        "    // 2. Count leads created this month",
        "    const leadsThisMonth = await LeadModel.countDocuments({",
        "      createdAt: { $gte: startOfMonth }",
        "    });",
        "",
        "    // 3. Get recent leads (e.g., last 10)",
        "    const recentLeads = await LeadModel.find()",
        "      .sort({ createdAt: -1 })",
        "      .limit(10);",
        "",
        "    res.json({ success: true, count: leadsThisMonth, leads: recentLeads });",
        "  } catch (error) {",
        "    console.error('Error fetching leads insights:', error);",
        "    res.status(500).json({ success: false, message: 'Failed to fetch leads insights' });",
        "  }",
        "});",
        "",
        "// Endpoint to get membership distribution (Active members by plan)",
        "app.get('/api/insights/membership-distribution', async (req, res) => {",
        "  try {",
        "    const MemberModel = require('./models/member.js');",
        "    const MembershipPlanModel = require('./models/membership.js');",
        "",
        "    // 1. Get all active plans to ensure we show even those with 0 members if needed, ",
        "    // or just rely on member aggregation. User asked: \"from (active member) members database get every memberships running\".",
        "",
        "    // 1. Get all active membership plans",
        "    const allPlans = await MembershipPlanModel.find({ status: 'Active' }).select('name');",
        "",
        "    // Create a map of plan names with 0 count",
        "    const planMap = {};",
        "    allPlans.forEach(plan => {",
        "      planMap[plan.name] = 0;",
        "    });",
        "",
        "    // 2. Aggregate active members by packageName",
        "    const memberCounts = await MemberModel.aggregate([",
        "      { $match: { status: 'Active' } },",
        "      {",
        "        $group: {",
        "          _id: \"$packageName\",",
        "          count: { $sum: 1 }",
        "        }",
        "      }",
        "    ]);",
        "",
        "    // 3. Update counts from aggregation",
        "    memberCounts.forEach(item => {",
        "      if (item._id) {",
        "        // If the plan exists in our map (is Active), update count.",
        "        // If not (maybe an old plan or one not in active set), we can decide to include it or not.",
        "        // Let's include it to be safe, ensuring all active members are counted.",
        "        planMap[item._id] = item.count;",
        "      }",
        "    });",
        "",
        "    // 4. Convert to array and sort",
        "    const distribution = Object.entries(planMap)",
        "      .map(([name, count]) => ({ _id: name, count }))",
        "      .sort((a, b) => b.count - a.count);",
        "",
        "    // Format for frontend",
        "    const formattedData = distribution.map(item => ({",
        "      name: item._id || 'Unknown Plan',",
        "      value: item.count",
        "    }));",
        "",
        "    res.json({ success: true, distribution: formattedData });",
        "  } catch (error) {",
        "    console.error('Error fetching membership distribution:', error);",
        "    res.status(500).json({ success: false, message: 'Error fetching distribution' });",
        "  }",
        "});",
        "",
        "// Endpoint to get members expiring soon (within next 7 days)",
        "app.get('/api/insights/expiring-soon', async (req, res) => {",
        "  try {",
        "    const MemberModel = require('./models/member.js');",
        "",
        "    const now = new Date();",
        "    const nextWeek = new Date();",
        "    nextWeek.setDate(now.getDate() + 7);",
        "",
        "    const expiringMembers = await MemberModel.find({",
        "      endDate: { $gte: now, $lte: nextWeek },",
        "      status: { $in: ['Active', 'Pending'] }",
        "    })",
        "      .select('memberId fullName packageName phone email area city profilePhoto status endDate')",
        "      .sort({ endDate: 1 });",
        "",
        "    res.json({ success: true, members: expiringMembers });",
        "  } catch (error) {",
        "    console.error('Error fetching expiring members:', error);",
        "    res.status(500).json({ success: false, message: 'Failed to fetch expiring members' });",
        "  }",
        "});",
        "",
        "// Endpoint to get peak hours data",
        "app.get('/api/insights/peak-hours', async (req, res) => {",
        "  try {",
        "    const AttendanceModel = require('./models/attendance.js');",
        "",
        "    // Get date 7 days ago",
        "    const sevenDaysAgo = new Date();",
        "    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);",
        "    sevenDaysAgo.setHours(0, 0, 0, 0);",
        "",
        "    const attendanceRecords = await AttendanceModel.find({",
        "      date: { $gte: sevenDaysAgo },",
        "      status: 'present' // assuming we only care about present members",
        "    }).select('time');",
        "",
        "    // Helper to extract hour from \"HH:MM AM/PM\"",
        "    const getHour = (timeStr) => {",
        "      // timeStr example: \"06:30 AM\" or \"6:30 AM\"",
        "      if (!timeStr) return null;",
        "      const parts = timeStr.trim().split(' ');",
        "      if (parts.length < 2) return null; // Unexpected format",
        "",
        "      const timeParts = parts[0].split(':');",
        "      let hour = parseInt(timeParts[0]);",
        "      const ampm = parts[1].toUpperCase();",
        "",
        "      if (ampm === 'PM' && hour !== 12) hour += 12;",
        "      if (ampm === 'AM' && hour === 12) hour = 0;",
        "",
        "      return hour;",
        "    };",
        "",
        "    const hourCounts = {};",
        "    attendanceRecords.forEach(record => {",
        "      const hour = getHour(record.time);",
        "      if (hour !== null) {",
        "        // We want to group by display hour e.g. \"6AM\", \"7AM\"",
        "        // Let's store as 0-23 first then format",
        "        hourCounts[hour] = (hourCounts[hour] || 0) + 1;",
        "      }",
        "    });",
        "",
        "    // Format for chart: sorted by hour",
        "    const peakHours = Object.keys(hourCounts)",
        "      .map(h => parseInt(h))",
        "      .sort((a, b) => a - b)",
        "      .map(h => {",
        "        let displayHour;",
        "        if (h === 0) displayHour = '12AM';",
        "        else if (h === 12) displayHour = '12PM';",
        "        else if (h > 12) displayHour = `${h - 12}PM`;",
        "        else displayHour = `${h}AM`;",
        "",
        "        return {",
        "          hour: displayHour,",
        "          count: hourCounts[h],",
        "          sortKey: h // Internal use if needed, but array is already sorted",
        "        };",
        "      });",
        "",
        "    res.json({ success: true, peakHours });",
        "  } catch (error) {",
        "    console.error('Error fetching peak hours:', error);",
        "    res.status(500).json({ success: false, message: 'Failed to fetch peak hours' });",
        "  }",
        "});",
        "",
        "// Endpoint to get attendance rate",
        "app.get('/api/insights/attendance-rate', async (req, res) => {",
        "  try {",
        "    const AttendanceModel = require('./models/attendance.js');",
        "    const MemberModel = require('./models/member.js');",
        "",
        "    // Get date 7 days ago",
        "    const sevenDaysAgo = new Date();",
        "    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);",
        "    sevenDaysAgo.setHours(0, 0, 0, 0);",
        "",
        "    // 1. Get unique members who attended in last 7 days",
        "    const uniqueAttendees = await AttendanceModel.distinct('entityId', {",
        "      date: { $gte: sevenDaysAgo },",
        "      type: 'member',",
        "      status: 'present'",
        "    });",
        "",
        "    const uniqueCount = uniqueAttendees.length;",
        "",
        "    // 2. Get total active members (not expired or cancelled)",
        "    const totalActiveMembers = await MemberModel.countDocuments({",
        "      status: { $nin: ['Expired', 'Cancelled'] }",
        "    });",
        "",
        "    // 3. Calculate rate",
        "    const rate = totalActiveMembers > 0",
        "      ? Math.round((uniqueCount / totalActiveMembers) * 100)",
        "      : 0;",
        "",
        "    res.json({",
        "      success: true,",
        "      attendanceRate: rate,",
        "      uniqueAttendees: uniqueCount,",
        "      totalActiveMembers",
        "    });",
        "  } catch (error) {",
        "    console.error('Error fetching attendance rate:', error);",
        "    res.status(500).json({ success: false, message: 'Failed to fetch attendance rate' });",
        "  }",
        "});",
        "",
        "// Endpoint to get lead conversion rate",
        "app.get('/api/insights/lead-conversion', async (req, res) => {",
        "  try {",
        "    const LeadModel = require('./models/lead.js');",
        "",
        "    const now = new Date();",
        "",
        "    // Current 30 days",
        "    const thirtyDaysAgo = new Date();",
        "    thirtyDaysAgo.setDate(now.getDate() - 30);",
        "    thirtyDaysAgo.setHours(0, 0, 0, 0);",
        "",
        "    // Previous 30 days (30-60 days ago)",
        "    const sixtyDaysAgo = new Date();",
        "    sixtyDaysAgo.setDate(now.getDate() - 60);",
        "    sixtyDaysAgo.setHours(0, 0, 0, 0);",
        "",
        "    // Current period: leads created in last 30 days",
        "    const currentTotalLeads = await LeadModel.countDocuments({",
        "      createdAt: { $gte: thirtyDaysAgo }",
        "    });",
        "",
        "    // Current period: leads having status 'converted' and updated in last 30 days",
        "    const currentConvertedLeads = await LeadModel.countDocuments({",
        "      status: 'converted',",
        "      updatedAt: { $gte: thirtyDaysAgo }",
        "    });",
        "",
        "    // Previous period: leads having status 'converted' and updated 30-60 days ago",
        "    const previousConvertedLeads = await LeadModel.countDocuments({",
        "      status: 'converted',",
        "      updatedAt: { $gte: sixtyDaysAgo, $lt: thirtyDaysAgo }",
        "    });",
        "",
        "    // Potential leads in previous period (total created)",
        "    const previousTotalLeads = await LeadModel.countDocuments({",
        "      createdAt: { $gte: sixtyDaysAgo, $lt: thirtyDaysAgo }",
        "    });",
        "",
        "    // Calculate conversion rates",
        "    const currentRate = currentTotalLeads > 0",
        "      ? Math.round((currentConvertedLeads / currentTotalLeads) * 100)",
        "      : 0;",
        "",
        "    const previousRate = previousTotalLeads > 0",
        "      ? Math.round((previousConvertedLeads / previousTotalLeads) * 100)",
        "      : 0;",
        "",
        "    // Calculate improvement",
        "    const improvement = currentRate - previousRate;",
        "",
        "    res.json({",
        "      success: true,",
        "      conversionRate: currentRate,",
        "      convertedCount: currentConvertedLeads,",
        "      improvement: improvement,",
        "      currentPeriod: {",
        "        total: currentTotalLeads,",
        "        converted: currentConvertedLeads",
        "      },",
        "      previousPeriod: {",
        "        total: previousTotalLeads,",
        "        converted: previousConvertedLeads",
        "      }",
        "    });",
        "  } catch (error) {",
        "    console.error('Error fetching lead conversion rate:', error);",
        "    res.status(500).json({ success: false, message: 'Failed to fetch lead conversion rate' });",
        "  }",
        "});",
        "",
        "// Endpoint to get lead sources breakdown",
        "app.get('/api/insights/lead-sources', async (req, res) => {",
        "  try {",
        "    const LeadModel = require('./models/lead.js');",
        "",
        "    // Aggregate leads by source",
        "    const sourceAggregation = await LeadModel.aggregate([",
        "      {",
        "        $group: {",
        "          _id: '$source',",
        "          count: { $sum: 1 }",
        "        }",
        "      },",
        "      { $sort: { count: -1 } }",
        "    ]);",
        "",
        "    // Calculate total leads",
        "    const totalLeads = sourceAggregation.reduce((sum, item) => sum + item.count, 0);",
        "",
        "    // Format with percentages and friendly names",
        "    const sourceNames = {",
        "      website: 'Website',",
        "      referral: 'Referrals',",
        "      social_media: 'Facebook/Insta',",
        "      walk_in: 'Walk-in',",
        "      event: 'Event',",
        "      other: 'Other'",
        "    };",
        "",
        "    const leadSources = sourceAggregation.map(item => ({",
        "      name: sourceNames[item._id] || item._id || 'Unknown',",
        "      value: totalLeads > 0 ? Math.round((item.count / totalLeads) * 100) : 0,",
        "      count: item.count",
        "    }));",
        "",
        "    res.json({",
        "      success: true,",
        "      leadSources,",
        "      totalLeads",
        "    });",
        "  } catch (error) {",
        "    console.error('Error fetching lead sources:', error);",
        "    res.status(500).json({ success: false, message: 'Failed to fetch lead sources' });",
        "  }",
        "});",
        "",
        "// Endpoint to get dashboard stats",
        "app.get('/gym/dashboard/stats', async (req, res) => {",
        "  try {",
        "    const MemberModel = require('./models/member.js');",
        "",
        "    const [total, active, expired, pending] = await Promise.all([",
        "      MemberModel.countDocuments(),",
        "      MemberModel.countDocuments({ status: 'Active' }),",
        "      MemberModel.countDocuments({ status: 'Expired' }),",
        "      MemberModel.countDocuments({ balanceAmount: { $gt: 0 }, status: 'Pending' })",
        "    ]);",
        "",
        "    res.json({",
        "      success: true,",
        "      stats: {",
        "        totalMembers: total,",
        "        activeMembers: active,",
        "        expiredMembers: expired,",
        "        pendingPayments: pending",
        "      }",
        "    });",
        "  } catch (error) {",
        "    console.error('Error fetching dashboard stats:', error);",
        "    res.status(500).json({ success: false, message: 'Failed to fetch dashboard stats' });",
        "  }",
        "});",
        "",
        "// Endpoint to get recent alerts for dashboard",
        "app.get('/gym/dashboard/recent-alerts', async (req, res) => {",
        "  try {",
        "    const MemberModel = require('./models/member.js');",
        "    const LeadModel = require('./models/lead.js');",
        "    const EquipmentModel = require('./models/equipment.js');",
        "    const StaffModel = require('./models/staff.js');",
        "    const StaffSalaryModel = require('./models/staffSalary.js');",
        "    const AttendanceModel = require('./models/attendance.js');",
        "",
        "    const now = new Date();",
        "    const today = new Date();",
        "    today.setHours(0, 0, 0, 0);",
        "",
        "    // 1. Pending Payments (Top 3)",
        "    const pendingPayments = await MemberModel.find({",
        "      balanceAmount: { $gt: 0 },",
        "      status: 'Pending'",
        "    }).sort({ updatedAt: -1 }).limit(3);",
        "",
        "    // 2. Expiring Soon (Top 3) - Filtered to exclude those with newer plans",
        "    const sevenDaysLater = new Date();",
        "    sevenDaysLater.setDate(today.getDate() + 7);",
        "    const expiringSoonPotential = await MemberModel.find({",
        "      endDate: { $gte: today, $lte: sevenDaysLater },",
        "      status: { $in: ['Active', 'Pending'] }",
        "    }).sort({ endDate: 1 });",
        "",
        "    const SubscriptionModel = require('./models/subscription.js');",
        "    const filteredExpiring = [];",
        "    for (const m of expiringSoonPotential) {",
        "      if (filteredExpiring.length >= 3) break;",
        "      const newerPlan = await SubscriptionModel.findOne({",
        "        memberId: m._id,",
        "        status: { $in: ['Active', 'Pending'] },",
        "        endDate: { $gt: m.endDate }",
        "      });",
        "      if (!newerPlan) {",
        "        filteredExpiring.push(m);",
        "      }",
        "    }",
        "    const expiringSoon = filteredExpiring;",
        "",
        "    // 3. Urgent Leads (Top 3)",
        "    const urgentLeads = await LeadModel.find({",
        "      nextFollowUpDate: { $lte: sevenDaysLater },",
        "      status: { $nin: ['converted', 'lost'] }",
        "    }).sort({ nextFollowUpDate: 1 }).limit(3);",
        "",
        "    // 4. Equipment Maintenance (Top 3)",
        "    const equipment = await EquipmentModel.find({",
        "      maintenanceSchedule: { $lte: sevenDaysLater }",
        "    }).sort({ maintenanceSchedule: 1 }).limit(3);",
        "",
        "    // Combine into a flattened list",
        "    const alerts = [",
        "      ...pendingPayments.map(m => ({",
        "        id: m._id,",
        "        type: 'payment',",
        "        title: `Pending Payment: ${m.fullName}`,",
        "        subtitle: `Balance: ${m.balanceAmount}`,",
        "        date: m.updatedAt,",
        "        icon: 'DollarSign'",
        "      })),",
        "      ...expiringSoon.map(m => ({",
        "        id: m._id,",
        "        type: 'renewal',",
        "        title: `Expiring Soon: ${m.fullName}`,",
        "        subtitle: `Ends on: ${new Date(m.endDate).toLocaleDateString()}`,",
        "        date: m.endDate,",
        "        icon: 'RefreshCcw'",
        "      })),",
        "      ...urgentLeads.map(l => ({",
        "        id: l._id,",
        "        type: 'lead',",
        "        title: `Follow-up: ${l.name}`,",
        "        subtitle: `Due: ${new Date(l.nextFollowUpDate).toLocaleDateString()}`,",
        "        date: l.nextFollowUpDate,",
        "        icon: 'UserPlus'",
        "      })),",
        "      ...equipment.map(e => ({",
        "        id: e._id,",
        "        type: 'maintenance',",
        "        title: `Maintenance: ${e.name}`,",
        "        subtitle: `Scheduled: ${new Date(e.maintenanceSchedule).toLocaleDateString()}`,",
        "        date: e.maintenanceSchedule,",
        "        icon: 'Wrench'",
        "      }))",
        "    ];",
        "",
        "    // Sort by date (most recent first for payment, soonest/oldest for others)",
        "    // For simplicity, just sort by date",
        "    alerts.sort((a, b) => new Date(b.date) - new Date(a.date));",
        "",
        "    res.json({ success: true, alerts: alerts.slice(0, 10) });",
        "  } catch (error) {",
        "    console.error('Error fetching recent alerts:', error);",
        "    res.status(500).json({ success: false, message: 'Failed to fetch recent alerts' });",
        "  }",
        "});",
        "",
        "app.get('/', (req, res) => {",
        "  res.send('Hello World!');",
        "});",
        "",
        "// ========================================",
        "// EXPIRY REMINDER AUTOMATION (CRON JOB)",
        "// ========================================",
        "",
        "/**",
        " * Run expiry reminder automation",
        " * Finds Active members with endDate within 7 days and sends webhook",
        " * Only sends once per day per member (tracks lastExpiryReminderDate)",
        " */",
        "async function runExpiryReminderAutomation() {",
        "  try {",
        "    const MemberModel = require('./models/member.js');",
        "",
        "    const today = new Date();",
        "    today.setHours(0, 0, 0, 0);",
        "",
        "    const sevenDaysLater = new Date();",
        "    sevenDaysLater.setDate(today.getDate() + 7);",
        "    sevenDaysLater.setHours(23, 59, 59, 999);",
        "",
        "    // Find active members with endDate within next 7 days",
        "    // AND who haven't been reminded today",
        "    const expiringMembers = await MemberModel.find({",
        "      status: 'Active',",
        "      endDate: { $gte: today, $lte: sevenDaysLater },",
        "      $or: [",
        "        { lastExpiryReminderDate: { $exists: false } },",
        "        { lastExpiryReminderDate: null },",
        "        { lastExpiryReminderDate: { $lt: today } }  // Not reminded today",
        "      ]",
        "    });",
        "",
        "    console.log(`[Expiry Reminder] Found ${expiringMembers.length} members needing reminder`);",
        "",
        "    let sentCount = 0;",
        "",
        "    for (const member of expiringMembers) {",
        "      // Check if they have a newer active plan already",
        "      const SubscriptionModel = require('./models/subscription.js');",
        "      const newerPlan = await SubscriptionModel.findOne({",
        "        memberId: member._id,",
        "        status: { $in: ['Active', 'Pending'] },",
        "        endDate: { $gt: member.endDate }",
        "      });",
        "",
        "      if (newerPlan) {",
        "        console.log(`[Expiry Reminder] Skipping ${member.fullName} - has newer active plan starting ${newerPlan.startDate.toLocaleDateString()}`);",
        "        continue;",
        "      }",
        "",
        "      // Calculate days until expiry",
        "      const endDate = new Date(member.endDate);",
        "      const timeDiff = endDate.getTime() - today.getTime();",
        "      const daysUntilExpiry = Math.ceil(timeDiff / (1000 * 60 * 60 * 24));",
        "",
        "      // Send webhook",
        "      await sendExpiryReminderWebhook(member, daysUntilExpiry);",
        "",
        "      // Mark as reminded TODAY",
        "      member.lastExpiryReminderDate = new Date();",
        "      await member.save();",
        "",
        "      sentCount++;",
        "      console.log(`[Expiry Reminder] Sent reminder for ${member.fullName} (${daysUntilExpiry} days left)`);",
        "    }",
        "",
        "    console.log(`[Expiry Reminder] Done. Sent ${sentCount} reminders.`);",
        "  } catch (error) {",
        "    console.error('[Expiry Reminder] Automation error:', error.message);",
        "  }",
        "}",
        "",
        "",
        "// Schedule the expiry reminder to run daily at 9:00 AM IST",
        "// Cron format: minute hour day month weekday",
        "cron.schedule('0 9 * * *', () => {",
        "  console.log('[Cron] Running daily expiry reminder automation at 9:00 AM');",
        "  runExpiryReminderAutomation();",
        "}, {",
        "  timezone: 'Asia/Kolkata'",
        "});",
        "",
        "// Manual trigger endpoint for testing",
        "app.post('/api/automation/run-expiry-reminder', async (req, res) => {",
        "  try {",
        "    console.log('[Expiry Reminder] Manual trigger initiated');",
        "    await runExpiryReminderAutomation();",
        "    res.json({ success: true, message: 'Expiry reminder automation completed' });",
        "  } catch (error) {",
        "    console.error('[Expiry Reminder] Manual trigger error:', error);",
        "    res.status(500).json({ success: false, message: error.message });",
        "  }",
        "});",
        "",
        "// ========================================",
        "// LEAD FOLLOW-UP AUTOMATION (CRON JOB)",
        "// ========================================",
        "",
        "/**",
        " * Run lead follow-up automation",
        " * Finds leads with nextFollowUpDate <= today and haven't been reminded today",
        " */",
        "async function runLeadFollowUpAutomation() {",
        "  try {",
        "    const LeadModel = require('./models/lead.js');",
        "",
        "    const today = new Date();",
        "    today.setHours(0, 0, 0, 0);",
        "",
        "    // Find leads with nextFollowUpDate <= today (including missed days)",
        "    // AND who haven't been reminded today",
        "    // AND who are not converted or lost",
        "    const leadsToFollowUp = await LeadModel.find({",
        "      nextFollowUpDate: { $lte: today },",
        "      status: { $nin: ['converted', 'lost'] },",
        "      $or: [",
        "        { lastFollowUpReminderDate: { $exists: false } },",
        "        { lastFollowUpReminderDate: null },",
        "        { lastFollowUpReminderDate: { $lt: today } }",
        "      ]",
        "    });",
        "",
        "    console.log(`[Lead Follow-up] Found ${leadsToFollowUp.length} leads needing follow-up`);",
        "",
        "    let sentCount = 0;",
        "",
        "    for (const lead of leadsToFollowUp) {",
        "      // Send webhook",
        "      await sendLeadFollowUpWebhook(lead);",
        "",
        "      // Mark as reminded TODAY",
        "      lead.lastFollowUpReminderDate = new Date();",
        "      await lead.save();",
        "",
        "      sentCount++;",
        "      console.log(`[Lead Follow-up] Sent reminder for ${lead.name}`);",
        "    }",
        "",
        "    console.log(`[Lead Follow-up] Done. Sent ${sentCount} reminders.`);",
        "  } catch (error) {",
        "    console.error('[Lead Follow-up] Automation error:', error.message);",
        "  }",
        "}",
        "",
        "// Schedule lead follow-up to run daily at 9:00 AM IST",
        "cron.schedule('0 9 * * *', () => {",
        "  console.log('[Cron] Running daily lead follow-up automation at 9:00 AM');",
        "  runLeadFollowUpAutomation();",
        "}, {",
        "  timezone: 'Asia/Kolkata'",
        "});",
        "",
        "// Manual trigger endpoint for testing",
        "app.post('/api/automation/run-lead-followup', async (req, res) => {",
        "  try {",
        "    console.log('[Lead Follow-up] Manual trigger initiated');",
        "    await runLeadFollowUpAutomation();",
        "    res.json({ success: true, message: 'Lead follow-up automation completed' });",
        "  } catch (error) {",
        "    console.error('[Lead Follow-up] Manual trigger error:', error);",
        "    res.status(500).json({ success: false, message: error.message });",
        "  }",
        "});",
        "",
        "app.listen(PORT, () => {",
        "  console.log(`Server is running on port ${PORT}`);",
        "  console.log('[Cron] Expiry reminder scheduled to run daily at 9:00 AM IST');",
        "  console.log('[Cron] Lead follow-up scheduled to run daily at 9:00 AM IST');",
        "",
        "  // Run automations on startup to catch up any missed runs",
        "  setTimeout(() => {",
        "    console.log('[Startup] Running catch-up automations...');",
        "    runExpiryReminderAutomation();",
        "    runLeadFollowUpAutomation();",
        "  }, 5000);",
        "});",
        ""
      ]
    },
    {
      "path": "client/package.json",
      "content": [
        "{",
        "  \"name\": \"client\",",
        "  \"private\": true,",
        "  \"version\": \"0.0.0\",",
        "  \"type\": \"module\",",
        "  \"scripts\": {",
        "    \"dev\": \"vite\",",
        "    \"build\": \"vite build\",",
        "    \"lint\": \"eslint .\",",
        "    \"preview\": \"vite preview\"",
        "  },",
        "  \"dependencies\": {",
        "    \"axios\": \"^1.13.2\",",
        "    \"browser-image-compression\": \"^2.0.2\",",
        "    \"chart.js\": \"^4.5.1\",",
        "    \"jspdf\": \"^3.0.4\",",
        "    \"jspdf-autotable\": \"^5.0.2\",",
        "    \"lucide-react\": \"^0.562.0\",",
        "    \"react\": \"^19.2.0\",",
        "    \"react-chartjs-2\": \"^5.3.1\",",
        "    \"react-dom\": \"^19.2.0\",",
        "    \"react-router-dom\": \"^7.11.0\",",
        "    \"react-toastify\": \"^11.0.5\",",
        "    \"recharts\": \"^3.6.0\"",
        "  },",
        "  \"devDependencies\": {",
        "    \"@eslint/js\": \"^9.39.1\",",
        "    \"@types/react\": \"^19.2.5\",",
        "    \"@types/react-dom\": \"^19.2.3\",",
        "    \"@vitejs/plugin-react\": \"^5.1.1\",",
        "    \"eslint\": \"^9.39.1\",",
        "    \"eslint-plugin-react-hooks\": \"^7.0.1\",",
        "    \"eslint-plugin-react-refresh\": \"^0.4.24\",",
        "    \"globals\": \"^16.5.0\",",
        "    \"vite\": \"^7.2.4\"",
        "  }",
        "}"
      ]
    },
    {
      "path": "server/package.json",
      "content": [
        "{",
        "  \"name\": \"server\",",
        "  \"version\": \"1.0.0\",",
        "  \"description\": \"\",",
        "  \"main\": \"index.js\",",
        "  \"scripts\": {",
        "    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",",
        "    \"start\": \"nodemon server.js\"",
        "  },",
        "  \"keywords\": [],",
        "  \"author\": \"\",",
        "  \"license\": \"ISC\",",
        "  \"type\": \"commonjs\",",
        "  \"dependencies\": {",
        "    \"axios\": \"^1.13.2\",",
        "    \"bcryptjs\": \"^3.0.3\",",
        "    \"cookie-parser\": \"^1.4.7\",",
        "    \"cors\": \"^2.8.5\",",
        "    \"csv-parser\": \"^3.2.0\",",
        "    \"dotenv\": \"^17.2.3\",",
        "    \"express\": \"^5.2.1\",",
        "    \"jsonwebtoken\": \"^9.0.3\",",
        "    \"jspdf\": \"^4.0.0\",",
        "    \"jspdf-autotable\": \"^5.0.7\",",
        "    \"mongoose\": \"^9.1.0\",",
        "    \"multer\": \"^2.0.2\",",
        "    \"node-cron\": \"^4.2.1\",",
        "    \"nodemailer\": \"^7.0.12\",",
        "    \"nodemon\": \"^3.1.11\",",
        "    \"pdfkit\": \"^0.17.2\"",
        "  }",
        "}"
      ]
    },
    {
      "path": "client/vite.config.js",
      "content": [
        "import { defineConfig } from 'vite'",
        "import react from '@vitejs/plugin-react'",
        "",
        "// https://vite.dev/config/",
        "export default defineConfig({",
        "  plugins: [react()],",
        "  server: {",
        "    proxy: {",
        "      '/gym': {",
        "        target: 'http://localhost:3000',",
        "        changeOrigin: true,",
        "        secure: false,",
        "      }",
        "    }",
        "  }",
        "})",
        ""
      ]
    },
    {
      "path": "server/fitness-api-server.js",
      "content": [
        "process.env.TZ = 'Asia/Kolkata';",
        "const express = require('express');",
        "const cors = require('cors');",
        "const fs = require('fs');",
        "const csv = require('csv-parser');",
        "const path = require('path');",
        "",
        "const app = express();",
        "app.use(cors());",
        "app.use(express.json());",
        "",
        "// Global Data Storage",
        "let dfFood = [];",
        "let dfWorkout = [];",
        "",
        "// ==============================================================================",
        "// 1. DATA LOADING & HELPERS",
        "// ==============================================================================",
        "",
        "// Helper: Parse numerical ranges (e.g., \"200-300\" -> 250)",
        "const parseRange = (val) => {",
        "    if (typeof val === 'string') {",
        "        val = val.replace('', '-').trim();",
        "        if (val.includes('-')) {",
        "            const parts = val.split('-').map(v => parseFloat(v));",
        "            if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {",
        "                return (parts[0] + parts[1]) / 2;",
        "            }",
        "        }",
        "    }",
        "    const num = parseFloat(val);",
        "    return isNaN(num) ? 0.0 : num;",
        "};",
        "",
        "// Helper: Categorize Muscles",
        "const getWorkoutCategory = (muscle) => {",
        "    const m = String(muscle).toLowerCase();",
        "    const categories = {",
        "        'Push': ['chest', 'pectoralis', 'tricep', 'deltoid', 'push', 'press', 'shoulder'],",
        "        'Pull': ['back', 'lat', 'rhomboid', 'bicep', 'trap', 'pull', 'row'],",
        "        'Legs': ['quad', 'glute', 'hamstring', 'leg', 'calf', 'adductor'],",
        "        'Core': ['abs', 'core', 'oblique'],",
        "        'Cardio': ['cardio', 'hiit', 'sprint']",
        "    };",
        "",
        "    for (const [cat, keywords] of Object.entries(categories)) {",
        "        if (keywords.some(k => m.includes(k))) return cat;",
        "    }",
        "    return 'Other';",
        "};",
        "",
        "// Helper: Load CSV Data",
        "const loadData = () => {",
        "    return new Promise((resolve, reject) => {",
        "        const foodPromise = new Promise((res) => {",
        "            const results = [];",
        "            if (!fs.existsSync('food.csv')) return res([]);",
        "            fs.createReadStream('food.csv')",
        "                .pipe(csv())",
        "                .on('data', (data) => {",
        "                    data['Calories (kcal)'] = parseRange(data['Calories (kcal)']);",
        "                    data['Protein (g)'] = parseRange(data['Protein (g)']);",
        "                    data['Carbs (g)'] = parseRange(data['Carbs (g)']);",
        "                    data['Fat (g)'] = parseRange(data['Fat (g)']);",
        "",
        "                    let type = (data['Type'] || '').trim().toLowerCase();",
        "                    if (type === 'snacks') type = 'snack';",
        "                    data['Type'] = type.charAt(0).toUpperCase() + type.slice(1); // Title Case",
        "",
        "                    const nonVegKeywords = ['chicken', 'egg', 'fish', 'mutton', 'prawn', 'meat', 'beef', 'pork', 'ham', 'bacon'];",
        "                    const dishName = (data['Dish Name'] || '').toLowerCase();",
        "                    data['Is_Veg'] = !nonVegKeywords.some(k => dishName.includes(k));",
        "",
        "                    if (data['Calories (kcal)'] > 0) results.push(data);",
        "                })",
        "                .on('end', () => res(results));",
        "        });",
        "",
        "        const workoutPromise = new Promise((res) => {",
        "            const results = [];",
        "            if (!fs.existsSync('workout.csv')) return res([]);",
        "            fs.createReadStream('workout.csv')",
        "                .pipe(csv())",
        "                .on('data', (data) => {",
        "                    data['Category'] = getWorkoutCategory(data['Target Muscle']);",
        "                    results.push(data);",
        "                })",
        "                .on('end', () => res(results));",
        "        });",
        "",
        "        Promise.all([foodPromise, workoutPromise]).then(([food, workout]) => {",
        "            dfFood = food;",
        "            dfWorkout = workout;",
        "            console.log(`Loaded ${dfFood.length} food items and ${dfWorkout.length} exercises.`);",
        "            resolve();",
        "        });",
        "    });",
        "};",
        "",
        "// Helper: Random Sample",
        "const sample = (arr, n = 1) => {",
        "    if (!arr || arr.length === 0) return [];",
        "    const shuffled = [...arr].sort(() => 0.5 - Math.random());",
        "    return shuffled.slice(0, n);",
        "};",
        "",
        "// ==============================================================================",
        "// 2. DIET ENGINE",
        "// ==============================================================================",
        "",
        "const generateDietDay = (targetCalories, isVeg, schedule) => {",
        "    const mealPools = {",
        "        'Breakfast': dfFood.filter(f => f.Type === 'Breakfast' && (isVeg ? f.Is_Veg : true)),",
        "        'Lunch': dfFood.filter(f => f.Type === 'Lunch' && (isVeg ? f.Is_Veg : true)),",
        "        'Dinner': dfFood.filter(f => f.Type === 'Dinner' && (isVeg ? f.Is_Veg : true)),",
        "        'Snack': dfFood.filter(f => f.Type === 'Snack' && (isVeg ? f.Is_Veg : true))",
        "    };",
        "",
        "    for (let i = 0; i < 50; i++) {",
        "        try {",
        "            let selection = {};",
        "            let rawCals = 0;",
        "",
        "            for (const [slot, typeKey] of schedule) {",
        "                const pool = mealPools[typeKey];",
        "                if (!pool || pool.length === 0) continue;",
        "",
        "                const item = sample(pool, 1)[0];",
        "                selection[slot] = item;",
        "                rawCals += item['Calories (kcal)'];",
        "            }",
        "",
        "            if (rawCals > 0) {",
        "                const scaler = targetCalories / rawCals;",
        "                if (scaler >= 0.5 && scaler <= 3.0) {",
        "                    const finalDay = {};",
        "                    let totalCals = 0;",
        "",
        "                    for (const [slot, item] of Object.entries(selection)) {",
        "                        const cals = item['Calories (kcal)'] * scaler;",
        "                        totalCals += cals;",
        "",
        "                        finalDay[slot] = {",
        "                            \"Dish\": item['Dish Name'],",
        "                            \"Portion\": `${scaler.toFixed(2)}x serving`,",
        "                            \"Calories\": Math.round(cals),",
        "                            \"Macros\": {",
        "                                \"P\": Math.round(item['Protein (g)'] * scaler),",
        "                                \"C\": Math.round(item['Carbs (g)'] * scaler),",
        "                                \"F\": Math.round(item['Fat (g)'] * scaler)",
        "                            }",
        "                        };",
        "                    }",
        "                    finalDay['Total_Calories'] = Math.round(totalCals);",
        "                    return finalDay;",
        "                }",
        "            }",
        "        } catch (err) {",
        "            continue;",
        "        }",
        "    }",
        "    return { \"Error\": \"Could not generate plan\" };",
        "};",
        "",
        "// ==============================================================================",
        "// 3. WORKOUT ENGINE",
        "// ==============================================================================",
        "",
        "const getExercises = (category, genderBias, count = 2) => {",
        "    let pool = dfWorkout.filter(w => w.Category === category);",
        "",
        "    if (genderBias === 'Male') {",
        "        pool = pool.filter(w => !String(w['Gender/Goal Bias']).toLowerCase().includes('female'));",
        "    } else if (genderBias === 'Female') {",
        "        pool = pool.filter(w => !String(w['Gender/Goal Bias']).toLowerCase().includes('male'));",
        "    }",
        "",
        "    if (pool.length === 0) return [];",
        "",
        "    const items = sample(pool, Math.min(count, pool.length));",
        "",
        "    return items.map(i => ({",
        "        \"Exercise\": i['Exercise Name'],",
        "        \"Sets_Reps\": category !== 'Cardio' ? \"3x8-12\" : \"20-30 mins\",",
        "        \"Target\": i['Target Muscle'],",
        "        \"Equipment\": i['Gym Equipment']",
        "    }));",
        "};",
        "",
        "const generateWorkoutWeek = (daysPerWeek, gender, goal) => {",
        "    const schedule = {};",
        "    let split = [];",
        "    let focus = {};",
        "",
        "    // Standard Logic",
        "    if (daysPerWeek === 3) {",
        "        split = ['Full Body', 'Rest', 'Full Body', 'Rest', 'Full Body', 'Rest', 'Rest'];",
        "        focus = { 'Full Body': ['Push', 'Pull', 'Legs', 'Core'] };",
        "    } else if (daysPerWeek === 5) {",
        "        split = ['Chest/Tri', 'Back/Bi', 'Legs', 'Shoulders', 'Arms/Core', 'Active Rest', 'Rest'];",
        "        focus = {",
        "            'Chest/Tri': ['Push'], 'Back/Bi': ['Pull'], 'Legs': ['Legs'],",
        "            'Shoulders': ['Push'], 'Arms/Core': ['Pull', 'Core']",
        "        };",
        "    } else {",
        "        // Default 4 Day",
        "        split = ['Upper A', 'Lower A', 'Rest', 'Upper B', 'Lower B', 'Active Rest', 'Rest'];",
        "        focus = {",
        "            'Upper A': ['Push', 'Pull'], 'Upper B': ['Push', 'Pull'],",
        "            'Lower A': ['Legs', 'Core'], 'Lower B': ['Legs', 'Core'],",
        "            'Active Rest': ['Cardio'], 'Rest': []",
        "        };",
        "    }",
        "",
        "    split.forEach((dayType, index) => {",
        "        const dayName = `Day_${index + 1}_${dayType.replace(' ', '_')}`;",
        "",
        "        if (dayType === 'Rest') {",
        "            schedule[dayName] = { \"Type\": \"Rest\", \"Exercises\": [] };",
        "            return;",
        "        }",
        "",
        "        const categories = focus[dayType] || ['Cardio'];",
        "        let dailyWorkout = [];",
        "",
        "        categories.forEach(cat => {",
        "            if (cat === 'Cardio' || (String(goal).includes('Loss') && dailyWorkout.length > 3)) {",
        "                dailyWorkout = [...dailyWorkout, ...getExercises('Cardio', gender, 1)];",
        "            } else {",
        "                dailyWorkout = [...dailyWorkout, ...getExercises(cat, gender, 2)];",
        "            }",
        "        });",
        "",
        "        schedule[dayName] = {",
        "            \"Type\": dayType,",
        "            \"Exercises\": dailyWorkout",
        "        };",
        "    });",
        "",
        "    return schedule;",
        "};",
        "",
        "// ==============================================================================",
        "// 4. API ROUTES",
        "// ==============================================================================",
        "",
        "app.post('/generate_diet', (req, res) => {",
        "    const tdee = parseFloat(req.body.USER_TDEE || 2000);",
        "    const goal = req.body.USER_GOAL || 'Maintenance';",
        "    const isVeg = Boolean(req.body.USER_IS_VEG);",
        "",
        "    const isGain = goal.toLowerCase().includes('gain');",
        "    const target = isGain ? tdee + 500 : tdee - 500;",
        "",
        "    let schedule = [",
        "        ['Breakfast', 'Breakfast'], ['Snack_1', 'Snack'],",
        "        ['Lunch', 'Lunch'], ['Snack_2', 'Snack'], ['Dinner', 'Dinner']",
        "    ];",
        "    if (isGain) schedule.push(['Bedtime_Snack', 'Snack']);",
        "",
        "    const plan = {};",
        "    // Generate only 1 week as requested",
        "    for (let w = 1; w <= 1; w++) {",
        "        plan[`Week_${w}`] = {};",
        "        for (let d = 1; d <= 7; d++) {",
        "            plan[`Week_${w}`][`Day_${d}`] = generateDietDay(target, isVeg, schedule);",
        "        }",
        "    }",
        "",
        "    res.json({",
        "        \"User\": { \"Goal\": goal, \"Target\": target },",
        "        \"Diet_Plan\": plan",
        "    });",
        "});",
        "",
        "app.post('/generate_workout', (req, res) => {",
        "    if (dfWorkout.length === 0) return res.status(500).json({ \"error\": \"workout.csv not found or empty\" });",
        "",
        "    const gender = req.body.USER_GENDER || 'Unisex';",
        "    const goal = req.body.USER_GOAL || 'General';",
        "    const days = parseInt(req.body.DAYS_PER_WEEK || 4);",
        "",
        "    const plan = {};",
        "    // Generate only 1 week as requested",
        "    for (let w = 1; w <= 1; w++) {",
        "        plan[`Week_${w}`] = generateWorkoutWeek(days, gender, goal);",
        "    }",
        "",
        "    res.json({",
        "        \"User\": { \"Gender\": gender, \"Goal\": goal, \"Days\": days },",
        "        \"Workout_Plan\": plan",
        "    });",
        "});",
        "",
        "// Start Server",
        "loadData().then(() => {",
        "    const PORT = 1000;",
        "    app.listen(PORT, () => {",
        "        console.log(`Fitness API Server (Standard Logic - 1 Week) running on http://localhost:${PORT}`);",
        "    });",
        "});",
        ""
      ]
    },
    {
      "path": "client/src/main.jsx",
      "content": [
        "import { StrictMode } from 'react'",
        "import { createRoot } from 'react-dom/client'",
        "import './styles/index.css'",
        "import App from './App.jsx'",
        "import {BrowserRouter} from 'react-router-dom'",
        "import { AppContextProvider } from './context/context.jsx'",
        "",
        "",
        "",
        "createRoot(document.getElementById('root')).render(",
        "  <BrowserRouter>",
        "",
        "  <AppContextProvider>",
        "     <App />",
        "  </AppContextProvider>",
        " ",
        "  </BrowserRouter>,",
        ")",
        ""
      ]
    }
  ]
}